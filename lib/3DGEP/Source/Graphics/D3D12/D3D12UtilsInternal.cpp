#include "D3D12UtilsInternal.h"

namespace D3D12GEPUtils {


void ThisIsMyInternalFunction()
{
	std::cout << "This is My D3D12GEP Internal Function" << std::endl;
}

bool CheckTearingSupport()
{
	BOOL allowTearing = FALSE;
	ComPtr<IDXGIFactory4> factory4;
	if (SUCCEEDED(CreateDXGIFactory1(IID_PPV_ARGS(&factory4))))
	{
		ComPtr<IDXGIFactory5> factory5;
		if (SUCCEEDED(factory4.As(&factory5))) // Try casting factory 4 to 5 (5 has support for tearing check)
		{
			if (FAILED(factory5->CheckFeatureSupport(
				DXGI_FEATURE_PRESENT_ALLOW_TEARING,
				&allowTearing, sizeof(allowTearing)))
				)
			{
				return false;
			}
			else
			{
				return true;
			}
		}
	}
	return false;
}

D3D12_COMMAND_LIST_TYPE CmdListTypeToD3D12(GEPUtils::Graphics::COMMAND_LIST_TYPE InCmdListType)
{
	switch (InCmdListType)
	{
	case GEPUtils::Graphics::COMMAND_LIST_TYPE::COMMAND_LIST_TYPE_DIRECT: return D3D12_COMMAND_LIST_TYPE::D3D12_COMMAND_LIST_TYPE_DIRECT;
	case GEPUtils::Graphics::COMMAND_LIST_TYPE::COMMAND_LIST_TYPE_BUNDLE: return D3D12_COMMAND_LIST_TYPE::D3D12_COMMAND_LIST_TYPE_BUNDLE;
	case GEPUtils::Graphics::COMMAND_LIST_TYPE::COMMAND_LIST_TYPE_COMPUTE: return D3D12_COMMAND_LIST_TYPE::D3D12_COMMAND_LIST_TYPE_COMPUTE;
	case GEPUtils::Graphics::COMMAND_LIST_TYPE::COMMAND_LIST_TYPE_COPY: return D3D12_COMMAND_LIST_TYPE::D3D12_COMMAND_LIST_TYPE_COPY;
	default: std::exception("D3D12 Command List Type undefined.");
	}
	return D3D12_COMMAND_LIST_TYPE::D3D12_COMMAND_LIST_TYPE_DIRECT;
}

D3D12_RESOURCE_STATES ResStateTypeToD3D12(GEPUtils::Graphics::RESOURCE_STATE InResState)
{
	switch (InResState)
	{
	case GEPUtils::Graphics::RESOURCE_STATE::PRESENT: return D3D12_RESOURCE_STATE_PRESENT;
	case GEPUtils::Graphics::RESOURCE_STATE::RENDER_TARGET: return D3D12_RESOURCE_STATE_RENDER_TARGET;
	default: std::exception("D3D12 Resource State Type undefined.");
	}
	return D3D12_RESOURCE_STATE_GENERIC_READ;
}

D3D12_RESOURCE_FLAGS ResFlagsToD3D12(GEPUtils::Graphics::RESOURCE_FLAGS InResFlags)
{
	D3D12_RESOURCE_FLAGS returnFlags = D3D12_RESOURCE_FLAG_NONE;
	if (InResFlags == GEPUtils::Graphics::RESOURCE_FLAGS::NONE)
		return returnFlags;
	if(InResFlags & GEPUtils::Graphics::RESOURCE_FLAGS::ALLOW_RENDER_TARGET)
		returnFlags |= D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
	if (InResFlags & GEPUtils::Graphics::RESOURCE_FLAGS::ALLOW_DEPTH_STENCIL)
		returnFlags |= D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
	if (InResFlags & GEPUtils::Graphics::RESOURCE_FLAGS::ALLOW_UNORDERED_ACCESS)
		returnFlags |= D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
	if (InResFlags & GEPUtils::Graphics::RESOURCE_FLAGS::DENY_SHADER_RESOURCE)
		returnFlags |= D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE;
	if (InResFlags & GEPUtils::Graphics::RESOURCE_FLAGS::ALLOW_CROSS_ADAPTER)
		returnFlags |= D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER;
	if (InResFlags & GEPUtils::Graphics::RESOURCE_FLAGS::ALLOW_SIMULTANEOUS_ACCESS)
		returnFlags |= D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS;
	if (InResFlags & GEPUtils::Graphics::RESOURCE_FLAGS::VIDEO_DECODE_REFERENCE_ONLY)
		returnFlags |= D3D12_RESOURCE_FLAGS::D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY;
		
	return returnFlags;
}

DXGI_FORMAT BufferFormatToD3D12(GEPUtils::Graphics::BUFFER_FORMAT InFormat)
{
	switch (InFormat)
	{
	case GEPUtils::Graphics::BUFFER_FORMAT::R16_UINT : return DXGI_FORMAT_R16_UINT;
	case GEPUtils::Graphics::BUFFER_FORMAT::R32G32B32_FLOAT: return DXGI_FORMAT_R32G32B32_FLOAT;
	case GEPUtils::Graphics::BUFFER_FORMAT::R8G8B8A8_UNORM: return DXGI_FORMAT_R8G8B8A8_UNORM;
	case GEPUtils::Graphics::BUFFER_FORMAT::D32_FLOAT: return DXGI_FORMAT_D32_FLOAT;
	default: std::exception("DXGI Buffer Format undefined.");
	}
	return DXGI_FORMAT_R16_UINT;
}

D3D12_PRIMITIVE_TOPOLOGY_TYPE PrimitiveTopologyTypeToD3D12(GEPUtils::Graphics::PRIMITIVE_TOPOLOGY_TYPE InPrimitiveTopologyType)
{
	switch (InPrimitiveTopologyType)
	{
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY_TYPE::PTT_UNDEFINED: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY_TYPE::PTT_POINT: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY_TYPE::PTT_LINE: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY_TYPE::PTT_TRIANGLE: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY_TYPE::PTT_PATCH: return D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH;
	default: std::exception("Primitive Topology Type undefined.");
	}
	return D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED;
}

D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopoToD3D12(GEPUtils::Graphics::PRIMITIVE_TOPOLOGY InPrimitiveTopo)
{
	switch (InPrimitiveTopo)
	{
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY::PT_UNDEFINED: return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_UNDEFINED;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY::PT_POINTLIST: return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_POINTLIST;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY::PT_LINELIST: return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_LINELIST;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY::PT_LINESTRIP: return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_LINESTRIP;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY::PT_TRIANGLELIST: return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST;
	case GEPUtils::Graphics::PRIMITIVE_TOPOLOGY::PT_TRIANGLESTRIP: return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP;
	default: std::exception("Primitive Topology undefined.");
		break;
	}
	return D3D12_PRIMITIVE_TOPOLOGY::D3D_PRIMITIVE_TOPOLOGY_UNDEFINED;
}

}
